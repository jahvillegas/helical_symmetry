import sys
import os
import random
import math
import numpy as np
from Bio.PDB import PDBParser, PDBIO, Structure, Model, Chain, Residue
from core.helical_symmetry import compute_helical_parameters  # Ensure correct import
from core.energy import *  # Ensure correct import

import csv

# 游릭 Load PDB File
def load_pdb(file_path):
    parser = PDBParser()
    structure = parser.get_structure("asymmetric_unit", file_path)
    return structure

# 游릭 Create Helical Assembly
def create_helical_assembly(structure, twist, rise, num_units):
    rotation_matrix, translation_vector = compute_helical_parameters(twist, rise)
    model = structure[0]
    assembly = Structure.Structure("helical_assembly")
    new_model = Model.Model(0)
    atom_serial = 1  # Track unique atom serial numbers

    for i in range(num_units):
        new_chain = Chain.Chain(chr(65 + i))  # Use A, B, C,... for chain IDs
        for residue in model.get_residues():
            # 游릭 Create a unique residue for each copy
            new_residue = Residue.Residue(
                (" ", residue.get_id()[1] + i * 100, " "),  # Unique residue ID
                residue.get_resname(),
                residue.get_segid()
            )
            for atom in residue.get_atoms():
                # Transform coordinates
                coord = atom.get_coord()
                transformed_coord = np.dot(np.linalg.matrix_power(rotation_matrix, i), coord) + i * translation_vector

                # 游릭 Create a new atom with a unique serial number
                new_atom = atom.copy()
                new_atom.set_coord(transformed_coord)
                new_atom.serial_number = atom_serial  # Unique serial number
                atom_serial += 1  # Increment serial number

                # Add transformed atom to new residue
                new_residue.add(new_atom)

            # Add new residue to chain
            new_chain.add(new_residue)

        # Add the new chain to the model
        new_model.add(new_chain)

    # Add the model to the assembly
    assembly.add(new_model)
    return assembly

# 游릭 Save Transformed PDB
def save_pdb(structure, output_file):
    io = PDBIO()
    io.set_structure(structure)
    io.save(output_file)
    print(f"Helical assembly saved as {output_file}")

# 游릭 Displace protein structure by a given translation vector
def displace_protein(structure, displacement_vector):
    for atom in structure.get_atoms():
        new_coord = atom.get_coord() + displacement_vector
        atom.set_coord(new_coord)
    return structure

# 游릭 Move protein structure toward the origin by a specified distance
def move_toward_origin(structure, distance: float):
    atom_coords = np.array([atom.get_coord() for atom in structure.get_atoms()])
    center_of_mass = atom_coords.mean(axis=0)
    direction = -center_of_mass / np.linalg.norm(center_of_mass)
    translation_vector = direction * distance

    for atom in structure.get_atoms():
        new_coord = atom.get_coord() + translation_vector
        atom.set_coord(new_coord)

    return structure

# 游릭 Monte Carlo Optimization Loop
def monte_carlo_optimization(pdb_file, n_steps, dr_max, Temp, num_units):
    f = open('src/data/monte_carlo.csv', 'w')
    
    # Initial parameter values (rise, twist, displacement)
    rise = 5.972
    twist = 32.818
    displacement = 15

    dof = [rise, twist, displacement]
    best_energy = 10000000000000000000000  # Large initial energy value
    
    for i in range(n_steps):
        # Load the asymmetric unit PDB file
        structure = load_pdb(pdb_file)

        # Center the protein
        translation_vector = np.array([-336.4, -336.4, -336.4])
        structure = displace_protein(structure, translation_vector)
        
        # Move toward the origin by a specified distance
        structure = move_toward_origin(structure, dof[2])

        # Create helical assembly
        assembly = create_helical_assembly(structure, dof[1], dof[0], num_units)

        # Save the helical assembly
        save_pdb(assembly, "src/data/R3K_N16_helical_assembly.pdb")

        # Compute energy of the current structure (using Rosetta or similar)
        energy_m = compute_rosetta_energy(assembly, minimize=False)

        # Choose a random degree of freedom to change
        selected_dof = random.randint(0, len(dof) - 1)
        dof_old = dof[selected_dof]
        
        # Apply a random change
        change = random.uniform(-1 * dr_max[selected_dof], dr_max[selected_dof])
        dof[selected_dof] = dof[selected_dof] + change
        
        # Load the structure again
        structure = load_pdb(pdb_file)
        structure = displace_protein(structure, translation_vector)
        structure = move_toward_origin(structure, dof[2])
        
        # Create a new helical assembly with modified parameters
        assembly = create_helical_assembly(structure, dof[1], dof[0], num_units)
        
        # Save the new helical assembly
        save_pdb(assembly, "src/data/R3K_N16_helical_assembly_modified.pdb")

        # Compute the energy for the new structure
        energy_n = compute_rosetta_energy(assembly, minimize=False)

        # Calculate the energy difference
        delta = energy_n - energy_m

        # Apply Metropolis acceptance criterion
        if delta > 0:
            zeta = random.uniform(0, 1)
            metropolis = math.exp((-1 * delta) / Temp) > zeta
            if not metropolis:
                dof[selected_dof] = dof_old

        # Write the results to the CSV file
        writer = csv.writer(f)
        writer.writerow([i, energy_m, dof])

    f.close()

# 游릭 Main function to run the Monte Carlo optimization
def main():
    pdb_file = "src/data/R3K_16_AU.pdb"  # Input PDB file
    n_steps = 20  # Number of Monte Carlo steps
    dr_max = [1, 5, 1]  # Max changes for rise, twist, displacement
    Temp = 300  # Temperature for the Metropolis criterion
    num_units = 9  # Number of asymmetric units
    
    monte_carlo_optimization(pdb_file, n_steps, dr_max, Temp, num_units)

if __name__ == "__main__":
    main()
